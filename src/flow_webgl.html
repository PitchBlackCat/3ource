<!DOCTYPE html>
<html>
<meta charset="utf-8">
<body>
	<style>
	body {
		font-family: monospace;
		overflow: hidden;
	}

	button {
		position: absolute;
		top: 0;
		left: 0;
	}

	#info {
		position: absolute;
	}

	#color_legend {
		position: absolute;
		z-index: 99;
		top: 40px;
		left: 100px;
		width: 80px;
		/*height: 200px;*/
	}

	#color_legend > div{
		width: 100%;
		display: block;
		height: 20px;
		color: #fff;
		padding: 0 10px;
		text-shadow: 0 0 10px rgb(0, 0, 0);
	}

	#commit {
		position: absolute;
		top: 50px;
		right: 100px;
		font-size: 20px;
		color: #fff;
	}

	</style>
	
	<script id="vertexShader" type="x-shader/x-vertex">

			precision mediump float;
			precision mediump int;

			uniform mat4 modelViewMatrix; // optional
			uniform mat4 projectionMatrix; // optional

			attribute vec3 position;
			attribute vec3 normal;
			attribute vec3 offset;
			attribute vec3 rotation;
			attribute vec2 uv;

			attribute vec3 color;

			varying vec3 vColor;
			varying vec2 vUv;
			varying vec3 vNormal;

			void main()	{

				vColor = color;


				float
				cosrx = cos(rotation.x),
				sinrx = sin(rotation.x),
				cosry = cos(rotation.y),
				sinry = sin(rotation.y),
				cosrz = cos(rotation.z),
				sinrz = sin(rotation.z);
				
				mat3 rotX = mat3(
					1.0, 0.0, 0.0,
					0.0, cosrx, sinrx,
					0.0, -sinrx, cosrx
				);

				mat3 rotY =  mat3(
					cosry, 0.0 , -sinry,
					0.0    , 1.0, 0.0,
					sinry, 0.0, cosry
				);

				mat3 rotZ =  mat3(
					cosrz , sinrz, 0.0,
					-sinrz, cosrz, 0.0,
					0.0 , 0.0    , 1.0
				);

				vec3 newPosition = offset + position * rotZ * rotY * rotX;
		
				vUv = uv;
				vNormal = normal;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );

			}

		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">
			precision mediump float;
			precision mediump int;

			uniform float time;
			uniform float depth;
			uniform sampler2D texture;

			varying vec3 vColor;
			varying vec2 vUv;

			vec4 pack_depth( const in float depth ) {

				const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );
				const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );
				vec4 res = fract( depth * bit_shift );
				res -= res.xxyz * bit_mask;
				return res;

			}

			void main()	{

				// gl_FragColor = vec4( 1., 1., 1., 1. );
				vec4 tex = texture2D(texture, vUv);

				// alpha test
				if (tex.a < 0.5) discard;

				if (depth > 0.) {

					gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );

				} else {

					vec4 color =  vec4(tex.xyz *  vColor, 1. );
					// color.xyz *= sin( time ) * 0.1 + 0.8;

					// gl_FragColor = vec4( 1. * sin(time), 1., 1., 1. );
					gl_FragData[ 0 ] =  color;
				}

			}

		</script>


		<script id="lineFragmentShader" type="x-shader/x-fragment">
			# extension GL_OES_standard_derivatives : enable

			precision mediump float;
			precision mediump int;

			uniform float time;
			uniform float depth;
			uniform sampler2D texture;

			varying vec3 vColor;
			varying vec2 vUv;
			varying vec3 vNormal;

			vec4 pack_depth( const in float depth ) {

				const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );
				const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );
				vec4 res = fract( depth * bit_shift );
				res -= res.xxyz * bit_mask;
				return res;

			}

			float inCurve(vec2 uv) {
				float sdf = uv.x * uv.x - uv.y;

				// if (abs(sdf) < 0.05) return -1.;
				if ((sdf) >- 0.05 && sdf < 0.) return -1.;
				return 1.;
				// on render < 0
			}

			float sdCuve(vec2 vUv) {
				// alpha test
				// if (tex.a < 0.5) discard;
				vec2 px = dFdx(vUv);
				vec2 py = dFdy(vUv);  
				// Chain rule  
				float fx = (2.*vUv.x)*px.x - px.y;  
				float fy = (2.*vUv.x)*py.x - py.y;  

				// Signed distance  
				float sd = (vUv.x*vUv.x - vUv.y) / sqrt(fx*fx + fy*fy);  
				// Linear alpha  

				// http://gamedev.stackexchange.com/questions/49373/how-to-draw-a-bezier-line-with-shaders

				// float alpha = 2.0 - abs(sd);
				// if (alpha < 0.) discard;

				float alpha = 0.5 - sd;
				// if (alpha < 0. || alpha > 1.) discard;

				// if (alpha > 1.)       // Inside
				// else if (alpha < 0)  // Outside
				// else Near boundary

				return sd;
			}

			float det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }

			vec2 closestPointInSegment( vec2 a, vec2 b ) {
				vec2 ba = b - a;
				return a + ba*clamp( -dot(a,ba)/dot(ba,ba), 0.0, 1.0 );
			}

			// From: http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf
			vec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2, float thickness) {

				float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // 𝛼,𝛽,𝛿(𝑝)

				if ( abs(2.0*a+b+d) < 0.001 ) return closestPointInSegment(b0,b2);
				// if (abs(b1.y - b0.y) < thickness) return closestPointInSegment(b0,b2);

				float f=b*d-a*a; // 𝑓(𝑝)
				vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;
				vec2 gf=2.0*(b*d21+d*d10+a*d20);
				gf=vec2(gf.y,-gf.x); // ∇𝑓(𝑝)
				vec2 pp=-f*gf/dot(gf,gf); // 𝑝′
				vec2 d0p=b0-pp; // 𝑝′ to origin
				float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // 𝛼,𝛽(𝑝′)
				// (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))
				float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0); // 𝑡̅
				return mix(mix(b0,b1,t),mix(b1,b2,t),t); // 𝑣𝑖= 𝑏(𝑡̅)

			}

			float approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2, float thickness) {
				return length(get_distance_vector(b0-p, b1-p, b2-p, thickness));
			}

			void main(void)
			{

				vec2 xy = vNormal.xy; // width height in actual pixels
				float thickness = vNormal.z;
				
				vec2 b0 = vec2(0.0, .5) * xy + vec2(thickness * 2.5, 0);
				vec2 b1 = vColor.xy; // mid control point
				vec2 b2 = vec2(1.0, .5) * xy - vec2(thickness * 2.5, 0);
				
				float d = approx_distance(vUv * xy, b0, b1, b2, thickness);	
				float a;
				
				if(d < thickness) {
				  a = 1.0;
				} else {
				  // Anti-alias the edge.
				  a = 1.0 - smoothstep(d, thickness, thickness+1.0);
				}
				
				// gl_FragColor = vec4(a,a,a, 1.0);
				if (a < 0.01) {
					discard;
				} else {
					gl_FragColor = vec4(a, a, a, a);	
				}

				// float g = vUv.x * 0.8 + 0.2;
				// gl_FragColor = vec4(g, g, g, 1.0);

				// gl_FragColor = vec4(gl_FragCoord.xy / 1000.,1.0, 1.0);

				
				
			}

			/*
			void main()	{

				// gl_FragColor = vec4( 1., 1., 1., 1. );
				// vec4 tex = texture2D(texture, vUv);

				// float x = inCurve(vUv);
				// if (x  > 0.) discard;

				if (depth > 0.) {
					gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );

				} else {
					vec4 color =  vec4(vColor, 1. );
					// vec4 color =  vec4(1., 1., 1. , 1. );
					gl_FragData[ 0 ] =  color;
				}

			}*/

		</script>


		<div id="info">
			<a href="http://threejs.org" target="_blank">three.js</a> - webgl force directed graphs wip
<br/>
			<button onclick="step()">Step</button>

		</div>



	<div id="commit">
		<div id="author"></div>
		<div id="message"></div>
		<div id="time"></div>
	</div>

	<div id="color_legend">
		<div>Legend</div>
	</div>
	<script>
		var color_legend = document.getElementById('color_legend');
	</script>


		<script src="test_files.js"></script>
		<script src="fs.js"></script>

		<script src="lib/three.min.js"></script>
		<script src="lib/ParticleGeometry.js"></script>

		<script src="lib/Detector.js"></script>
		<script src="lib/stats.min.js"></script>

		<script src="three_rendering.js"></script>
		<script src="force_directed.js"></script>
		<script src="slidebar.js"></script>

		<script src="source.js"></script>
		
	<script>
		var url = '../data/test.json';
		getLog('../data/filenames.json', url, readTimeline);

		var fs;
		var t;
		var at = -1;

		var previousTree = [];

		var slidebar = new Slidebar(600, 50);
		slidebar.onScroll.do(function(v) {
			console.log(v);
			at = v;
			display();
		});

		document.body.appendChild(slidebar.dom);

		function readTimeline(timeline) {
			t = timeline.concat().reverse();
			step();
		}

		document.body.addEventListener('keydown', step);

		function step(e) {
			if (e) { // which
				switch (e.keyCode) {
					case 74: // j
					case 37: // left
						at--;
						break;

					case 75: // k
					// case 40: // down
					case 39: // right
						at++;
						break;
					case 82:
						camera.rotation.z += 0.1;
						break;
					case 89:
						camera.rotation.z -= 0.1;
						break;
					case 85:
						camera.rotation.x += 0.01;
						break;
					case 84:
						camera.rotation.x -= 0.01;
						break;
				}
			} else {
				at++;
			}
			if (at >= t.length) at = t.length - 1;
			if (at < 0) at = 0;
			display();
		}

		function display() {

			if (at > t.length - 1) return;
			// var
			commit = t[at];
			slidebar.setValue(at);
			slidebar.setMax(t.length - 1);

			var modified = commit.change.filter(function(modification) {
				return modification.op == 'M';
			});

			var changeset = generateChangeset(commit.tree, previousTree);
			changeset = changeset.concat(modified);
			changeset.sort(amdSort);

			// changeset.forEach(onModify);

			changeset.forEach(function(mod) {
				queue.add(mod);
			});


			author.innerText = '#' + (at + 1) + ' ' + commit.author + ':\n';
			message.innerText = commit.message;
			time.innerText = new Date(commit.date * 1000);

			previousTree = commit.tree;

		}

		/*
		 * ExecutionQueue creates a queue up of execution jobs
		 * and runs them in slightly delayed batches.
		 *
		 * Currently, uses its build in timer
		 */
		function ExecutionQueue(executor) {
			this.queue = [];
			this.executor = executor;
		}

		ExecutionQueue.prototype.add = function(func) {
			this.queue.push(func);
		};

		ExecutionQueue.prototype.clear = function() {
			this.queue = [];
		};

		ExecutionQueue.prototype.executeAll = function() {
			var queue = this.queue, i = 0, il = queue.length;
			var exec = this.executor;
			for (; i < il; i++) {
				exec(queue[i]);
			}

			this.clear();
		};

		ExecutionQueue.prototype.start = function() {
			this._timer = setInterval(this.execute.bind(this), 100);
		};

		ExecutionQueue.prototype.stop = function() {
			if (this._timer) clearInterval(this._timer);
		};

		ExecutionQueue.prototype.execute = function() {
			var queue = this.queue, i = 0, il = queue.length;
			var exec = this.executor;

			for (;i < 100 && i < il; i++) {
				exec(queue[i]);
			}

			if (i) this.queue.splice(0, i);
		};

		var queue = new ExecutionQueue(onModify);
		queue.start();

		function onModify(modification) {

			switch(modification.op) {
				case 'A':
					fs.touch(modification.file);
					break;
				case 'D':
					fs.rm(modification.file);
					break;
				case 'M':
					var g = fs.find(modification.file).graphNode;
					// TODO highlight colors / nicer movements
					// add forces / drag user
					// g.x += (Math.random() - 0.5) * 100;
					// g.y += (Math.random() - 0.5) * 100;
					g.life = 0;
					break;
				default:
					console.log(modification.op, 'not supported');
			}
		}

		function initSimulations() {
			fs = new FS();
			fs.root.graphNode = newNode('.', false);

			fs.root.onAdd.do(onNodeAdd);
			fs.root.onRemove.do(onNodeRemove);

		}

		function init() {
			initDrawings();
			initSimulations();

			// setInterval(function() {at+=5; //console.log(at);
			// 	display(); }, 50);;
		}

		// Fit button
		window.addEventListener('mousewheel', function(e) {
			// TODO position mouse on where it zooms
			camera.position.z -= e.wheelDeltaY;
		});

		var mousex = null, mousey = null;
		window.addEventListener('mousedown', function(e) {
			mousex = e.offsetX;
			mousey = e.offsetY;
		});

		window.addEventListener('mousemove', function(e) {
			// TODO use actual distance
			if (mousex !== null && mousey !== null) {
				camera.position.x -= e.offsetX - mousex;
				camera.position.y += e.offsetY - mousey;
				mousex = e.offsetX;
				mousey = e.offsetY;
			}
		});

		window.addEventListener('mouseup', function(e) {
			mousex = null;
			mousey = null;
		});



		init();
	</script>

</body>
</html>
