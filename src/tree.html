<html>
<body>
	<style>
	body {
		font-family: monospace;
	}
	#graph {
		position: absolute;
	}

	#container {
		position: absolute;
		left: 120px;
		white-space: nowrap; /*pre*/
	}

	.log {
		/*border: 1px solid blue;*/
		height: 25px;
	}
	</style>
	<script src="lib/three.min.js"></script>
	<script src="source.js"></script>
	<div id="container"></div>
	<script>

	var plane = new THREE.PlaneGeometry( 20, 20 );
	var materials = [];
	for (i=0;i<50;i++) {
		materials.push(new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } ));
	}
	var allnodes = [];
	// var material = new THREE.MeshBasicMaterial( {color: new THREE.Color( 0xff0000 )} );

	// mixin of a TreeNode (file system representation) and a Three.js object
	var TreeNodeMixin = {
		init2: function(name) {
			this.name = name;
			this.fsChildren = {};

			// this.position2 = new THREE.Vector3();
			// this.position2.x = this.position.x = (Math.random() - .5) * 100;
			// this.position2.y = this.position.y = (Math.random() - .5) * 100;
			this.position.dx = Math.random() - .5;
			this.position.dy = Math.random() - .5;
		},

		get: function(path) {
			return this.fsChildren[path];
		},

		getOrCreate: function(path) {
			var node = this.get(path);
			if (!node) {
				node = this.create(path);
			}
			return node;
		},

		create: function(path) {
			var node;
			if (path.charAt(path.length-1)=='/') {
				node = new TreeNode(path);
			} else {
				node = new FileNode(path, plane, materials[Math.random() * materials.length]);
			}
			this.add(node);
			this.fsChildren[path] = node;
			allnodes.push(node);
			return node;
		},

		ls: function() {
			var names = [];
			for (var i in this.fsChildren) {
				names.push(this.fsChildren[i].name);
			}
			return names;
		},

		isDir: function() {
			return this.name.charAt(this.name.length-1) == '/';
		},

		isEmpty: function() {
			return this.ls().length == 0;
		},

		rm: function(name) {
			var node = this.fsChildren[name];
			delete this.fsChildren[name];
			this.remove(node);
			allnodes.splice(allnodes.indexOf(node), 1);
		},


		addPath: function(filename) {
			var paths, i, il, path, node;
			paths = filename.split('/');
			node = this; // start
			for (i=0, il=paths.length;i<il;i++) {
				path = paths[i];
				if (i<il-1) {
					node = node.getOrCreate(path + '/');
				} else {
					node = node.getOrCreate(path);
				}
			}
		},

		getPath: function(filename) {
			var paths, i, il, path, node, tmp;
			paths = filename.split('/');
			node = this; // start
			for (i=0, il=paths.length;i<il;i++) {
				path = paths[i];
				tmp = node.get(path + '/');
				if (tmp) {
					node = tmp;
				} else {
					node = node.get(path);
				}
			}
			return node;
		},

		removePath: function(filename) {
			// traverse in and remove by layer.
			var paths, i, il, path, node;
			paths = filename.split('/');
			node = this;
			var nodes = [root];
			for (i=0, il=paths.length;i<il;i++) {
				path = paths[i];
				if (i<il-1) {
					node = node.getOrCreate(path + '/'); // getOrCreate get
					nodes.push(node);
				} else {
					node = node.getOrCreate(path);
				}
			}
			var parent;
			for (i=nodes.length;i--;) {
				parent = nodes.pop();
				parent.rm(node.name);
				if (!parent.isEmpty()) break;
				node = parent;
			}

		},

		simulate: function() {
			var child, children = this.children;
			var files = [];
			var folders = [];
			var i, il, j;
			for (i=0, il=children.length;i<il;i++) {
				child = children[i];

				if (child instanceof FileNode) {
					files.push(child);
				} else if (child instanceof TreeNode) {
					folders.push(child);
					child.simulate();
				}
			}

			var n, n2;
			n = this;
			n.position.dx -= n.position.x * 0.001;
			n.position.dy -= n.position.y * 0.001;
			var d;

			for (i=files.length; i--; ) {
				n = files[i];
				// Gravity towards center
				n.position.dx -= n.position.x * 0.001;
				n.position.dy -= n.position.y * 0.001;

				for (j=0;j<i;j++) {
					n2 = files[j];
					if (i==j) continue;

					// tmp.subVectors(n2.position, n.position);
					// d = tmp.distance();
					// if (d < 50) {
					// 	// n2.position += d / 50 * something;

					// }

				}
			}
		}
	};

	function mixin(o, type) {
		var newType = o.init;
		newType.prototype = Object.create( type.prototype );
		for (var i in o) {
			if (i!=='init')
				newType.prototype[i] = o[i];
		}
		return newType;
	}

	FileNodeMixin = {};
	for (var i in TreeNodeMixin) {
		FileNodeMixin[i] = TreeNodeMixin[i];
	}

	TreeNodeMixin.init = function(name) {
		THREE.Object3D.call( this );
		this.init2(name);
	}

	FileNodeMixin.init = function(name, geometry, material) {
		THREE.Mesh.call( this, geometry, material );
		this.init2(name);
	}

	TreeNode = mixin(TreeNodeMixin, THREE.Object3D);
	FileNode = mixin(FileNodeMixin, THREE.Mesh);

	var scene = new THREE.Scene();
	var root = new TreeNode('/');

	var tmp = new THREE.Vector3();

	var url = '../data/test.json';
	requestLog(url, readTimeline);

	var target = new THREE.Vector3( 0, 0, 0 );

	function readTimeline(timeline) {
		t = timeline;

		function compare(a, b) {
			return b.date - a.date;
		}
		// Date order vs Ancestor order
		// timeline.sort(compare);

		u = timeline.concat()
		timeline.reverse();

		var i,il, commit, j, entry, filename;
		var added, deleted, modified;
		for (i=0;i<8;i++) { //t.length
			commit = timeline[i];
			files = commit.files;
			mods = {A:[], D:[], M:[]};
			if (!files) {
				// merge cases
				console.log(commit);
				continue;
			}
			for (j=0; j<files.length; j++) {
				entry = files[j];
				mods[entry.charAt(0)].push(entry.substring(2));
			}
			// console.log(mods);
			commit.mods = mods;
			// console.log(commit)

			var path;
			for (j=0;j<mods.A.length;j++) {
				path = mods.A[j];
				root.addPath(path);
			}

			for (j=0;j<mods.D.length;j++) {
				path = mods.D[j];
				root.removePath(path);
			}
		}

		initScene();

	}

	function initScene() {
		camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 2100 );
		// camera.position.y = 150;
		camera.position.z = 500;
		camera.lookAt(target);
		scene.add(root);

		renderer = new THREE.WebGLRenderer();
		// renderer = new THREE.CanvasRenderer();
		renderer.setSize( window.innerWidth, window.innerHeight );

		document.body.appendChild( renderer.domElement );

		// moo = new THREE.Mesh(plane, material);
		// scene.add(moo);

		render();

	}


	function render() {
		var node;

		for (var i=0, il=allnodes.length;i<il;i++) {
			node = allnodes[i];

			node.position.x += node.position.dx;
			node.position.y += node.position.dy;
			// tmp.copy(node.position);
			// node.position2.copy(node.position2);
			// node.position2.copy(tmp);
			// node.position2.multiplyScalar(2).sub(node.position);

		}

		root.simulate();

		renderer.render( scene, camera );
		requestAnimationFrame(render);
	}

	</script>
</body>
</html>