<html>
<body>
	<style>
	body {
		font-family: monospace;
	}
	#graph {
		position: absolute;
	}

	#container {
		position: absolute;
		left: 120px;
		white-space: nowrap; /*pre*/
	}

	.log {
		/*border: 1px solid blue;*/
		height: 25px;
	}
	</style>
	<script src="lib/three.min.js"></script>
	<div id="container"></div>
	<script>

	// TODO - make this a mixin of a TreeNode (file system representation) and a Three.js object
	TreeNode = function(name) {
		THREE.Object3D.call( this );
		this.name = name;
		this.fsChildren = {};
	}
	TreeNode.prototype = Object.create( THREE.Object3D.prototype );

	TreeNode.prototype.get = function(path) {
		return this.fsChildren[path];
	}

	TreeNode.prototype.getOrCreate = function(path) {
		var node = this.get(path);
		if (!node) {
			node = this.create(path);
		}
		return node;
	}

	TreeNode.prototype.create = function(path) {
		var node = new TreeNode(path);
		this.add(node);
		this.fsChildren[path] = node;
		return node;
	}

	TreeNode.prototype.ls = function() {
		var names = [];
		for (var i in this.fsChildren) {
			names.push(this.fsChildren[i].name);
		}
		return names;
	}

	TreeNode.prototype.isDir = function() {
		return this.name.charAt(this.name.length-1) == '/';
	}

	TreeNode.prototype.isEmpty = function() {
		return this.ls().length == 0;
	}

	TreeNode.prototype.rm = function(name) {
		var node = this.fsChildren[name];
		delete this.fsChildren[name];
		this.remove(node);
	}


	TreeNode.prototype.addPath = function(filename) {
		var paths, i, il, path, node;
		paths = filename.split('/');
		node = this; // start
		for (i=0, il=paths.length;i<il;i++) {
			path = paths[i];
			if (i<il-1) {
				node = node.getOrCreate(path + '/');
			} else {
				node = node.getOrCreate(path);
			}
		}
	}

	TreeNode.prototype.getPath = function(filename) {
		var paths, i, il, path, node, tmp;
		paths = filename.split('/');
		node = this; // start
		for (i=0, il=paths.length;i<il;i++) {
			path = paths[i];
			tmp = node.get(path + '/');
			if (tmp) {
				node = tmp;
			} else {
				node = node.get(path);
			}
		}
		return node;
	}

	TreeNode.prototype.removePath = function(filename) {
		// traverse in and remove by layer.
		var paths, i, il, path, node;
		paths = filename.split('/');
		node = this;
		var nodes = [root];
		for (i=0, il=paths.length;i<il;i++) {
			path = paths[i];
			if (i<il-1) {
				node = node.get(path + '/');
				nodes.push(node);
			} else {
				node = node.get(path);
			}
		}
		var parent;
		for (i=nodes.length;i--;) {
			parent = nodes.pop();
			parent.rm(node.name);
			if (!parent.isEmpty()) break;
			node = parent;
		}

	}
	var scene = new THREE.Scene();
	var root = new TreeNode('/');

	var request = new XMLHttpRequest();
	var url = '../data/test.json';
	var u;
	request.open( 'GET', url, true );
	request.onload = function(e) {
		console.time('decode');
		var timeline = JSON.parse(request.response);
		console.timeEnd('decode');
		readTimeline(timeline);
	}
	request.send(null);

	function readTimeline(timeline) {
		t = timeline;
		u = timeline.concat()
		timeline.reverse();

		var i,il, commit, j, entry, filename;
		var added, deleted, modified;
		for (i=0;i<5;i++) {
			commit = timeline[i];
			files = commit.files;
			mods = {A:[], D:[], M:[]};
			for (j=0; j<files.length; j++) {
				entry = files[j];
				mods[entry.charAt(0)].push(entry.substring(2));
			}
			console.log(mods);
			commit.mods = mods;
			// console.log(commit)

			var path;
			for (j=0;j<mods.A.length;j++) {
				path = mods.A[j];
				root.addPath(path);
			}

			for (j=0;j<mods.D.length;j++) {
				path = mods.D[j];
				root.removePath(path);
			}
		}

	}

	</script>
</body>
</html>