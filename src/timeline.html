<html>
<body>
	<style>
	body {
		font-family: monospace;
		background: #202020;
		color: #979797;
		overflow: hidden;
	}
	#graph {
		position: absolute;
	}

	#container {
		/*display: none;*/
		position: absolute;
		left: 120px;
		white-space: nowrap; /*pre*/
		font-size: 12px;
	}

	#timeline_panel {
		border: 1px solid white;
		height: 600px;
		overflow: auto;
		position: relative;
		width: 100%;
	}

	#panel_spacer {
		height: 14000px;
	}

	#sliding_window {
		position: absolute;
		top: 0
	}

	</style>

	<div id="timeline_panel">
		<div id="sliding_window">
			<div id="container"></div>
		</div>

		<div id="panel_spacer"></div>
	</div>
	
	<script src="source.js"></script>
	<script>

	"use strict"
	// TODO grep linkable commit messages, urls, authors, commits numbers
	// TODO virtual rendering for resizing viewport
	// TODO nicer graphs
	// TODO refactor this into GitLogViewer class

	/*OPTIONS*/

	var TRACK_WIDTH = 10;
	var DOT_SIZE = 3;
	var ROW_HEIGHT = 20;

	var currentRow = 0; // Current Row to Render from
	var targetRows = 50;
	var bufferRows = 0;
	var scrollIncrement = 0;

	// Pwn CSS
	var sheet = document.styleSheets[document.styleSheets.length - 1];
	function addRule(selector, styles) {
		if (sheet.insertRule) sheet.insertRule(selector + " {" + styles + "}", sheet.cssRules.length);
		else if (sheet.addRule) sheet.addRule(selector, styles);
	}
	/* CUSTOMIZATIONS */
	// Text colors (http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs)
	var Bright = 0, Bold = 1;
	var Scheme = {
		Black: '#202020/#555555'.split('/'),
		Red: '#5d1a14/#da4939'.split('/'),
		Green: '#424e24/#a5c261,'.split('/'),
		Yellow: '#6f5028/#ffc66d'.split('/'),
		Blue: '#263e4e/#6d9cbe'.split('/'),
		Magenta: '#3e1f50/#a256c7'.split('/'),
		Cyan: '#234e3f/#62c1a1'.split('/'),
		White: '#979797/#ffffff'.split('/')
	};

	addRule('.log', 'height: ' + ROW_HEIGHT + 'px;')
	addRule('.hash', 'color: ' + Scheme.Blue[Bold] + ';')
	addRule('.time', 'color: ' + Scheme.Green[Bold] + ';')
	addRule('.author', 'color: ' + Scheme.Cyan[Bold] + ';')
	addRule('.message', 'color: ' + Scheme.White[Bold] + ';')

	// Steal colors from https://github.com/tclh123/commits-graph/blob/master/js/dist/jquery.commits-graph.js#L152
	var colors =[
		"#e11d21",
		//"#eb6420",
		"#fbca04",
		"#009800",
		"#006b75",
		"#207de5",
		"#0052cc",
		"#5319e7",
		"#f7c6c7",
		"#fad8c7",
		"#fef2c0",
		"#bfe5bf",
		"#c7def8",
		"#bfdadc",
		"#bfd4f2",
		"#d4c5f9",
		"#cccccc",
		"#84b6eb",
		"#e6e6e6",
		"#ffffff",
		"#cc317c"
	];

	// Classic Style
	// var colors = ['black', '#ee8', 'red', 'green', 'blue'];


	// TODO handle retina displays
    // TODO click handlers
	// window.devicePixelRatio

	var url = '../data/test.json';
	getLog('../data/filenames.json', url, readTimeline);


	// utils
	function replacer(w) {
		return function() { return w };
	}

	function compare(a, b) {
		return b.date - a.date;
	}

	function readTimeline(timeline) {
		// console.log(timeline);
		window.t = timeline;
		// u = timeline.reverse();
		var i, il, commit;
		var hashes = {};

		// Date order vs Ancestor order
		timeline.sort(compare);

		// create hashes
		for (i=0,il=timeline.length;i<il;i++) {
			commit = timeline[i];
			commit.children = [];
			hashes[commit.hash] = commit;
		}

		var parents, hash;

		// create reverse references
		for (i=0;i<il;i++) {
			commit = timeline[i];
			parents = commit.parents;
			for (j=0;j<parents.length;j++) {
				hash = parents[j];
				hashes[hash].children.push(commit);
			}
		}

		// Graphing strategies
		// 1. pending parents first (gitk, jetbrains, git log --graph)
		// 2. Current node first, pending parents, remaining parents (sourcetree, gitx)
		// 3. Current parent, remaining parents, pending parents. (soucetree)
		// 4. force layout (vizgraph)

		// TODO
		// Bezier
		// Mouse over interactivity

		// var ctx;

		var e;
		var pendingPaths = [];
		var p;
		var LINK_PORTION = 0.28;

		console.time('graphing');

		
		var nodeTrack; // Lane the node is on
		var nodeTracks = []; // Track which lane the node is at for every row

		var tracks = []; // Array of Arrays
		var trackCounter = 0; // Unique Tracks


		function CommitPath(hash, row) {
			this.targetHash = hash; // hash for matching parent
			this.row = row; // commit sequence id
			this.length = length;
		}

		// Start with childrens / latest.
		/* Compute Graph Tracks */

		var commit;
		for (i=0, il=timeline.length; i<il; i++) {
			commit = timeline[i];

//			if (i > 100) break;

			// current parents == where you came from
			var currentPaths = [];
			for (j=0; j<commit.parents.length; j++) {
				currentPaths.push(new CommitPath(commit.parents[j], i))
			}

			nodeTrack = null;
			var merges = 0;

			// Pending Tracks
			for (j=0;j<pendingPaths.length;j++) {

				p = pendingPaths[j];

				var currentTrack = tracks[p.id];

				var currentLane;
				var endTrack = null;
				var first;
				var tmp;

				currentLane = p.lane;

				if (p.targetHash==commit.hash) {
                    // this commit track path ends here
					first = nodeTrack === null;

					if (first) nodeTrack = j;
					endTrack = nodeTrack;

					if (first && currentPaths.length) {

						tmp = currentPaths.shift()
						tmp.lane = j;
						tmp.id = pendingPaths[j].id;
						pendingPaths[j] = tmp;


					} else {
                        // p.length==0 &&
						if (p.prevLane!=p.lane) {
							currentLane = p.prevLane;
						}

						pendingPaths.splice(j, 1);
						merges++;
						j--;
					}

				} else {
					p.lane -= merges;
					endTrack = p.lane;
					p.length++;
				}

                if (!currentTrack.length) {
                    currentTrack.push({lane: p.prevLane, row: p.row});
                } // parent's row at node track

                if (currentLane != p.prevLane) {
                    // For creating angular cut off
                    if (currentLane != endTrack) {
                        // reduce ugliness
                        currentTrack.push({lane: endTrack, row: p.row});
                    } else {
                        currentTrack.push({lane: currentLane, row: p.row});
                    }
                    // parent's row at previous track's lane
                }

                currentTrack.push({lane: endTrack, row: i}); // child's row
				p.row = i;

			}

			if (nodeTrack===null) {
				nodeTrack = 0;
			}

			// Merge current parents into a pending array
			for (j=0;j<currentPaths.length;j++) {
				p = currentPaths[j];

				p.id = trackCounter++;
				p.lane = pendingPaths.length;
				tracks[p.id] = [];

				pendingPaths.push(p);
			}

			// All
			for (j=0;j<pendingPaths.length;j++) {
				p = pendingPaths[j];

				// Draw connecting lines
				if (p.length==0) {
					p.prevLane = nodeTrack;
				} else {
					p.prevLane = p.lane;
				}

			}

			nodeTracks.push(nodeTrack);
		}

		console.timeEnd('graphing');

		// POST PROCESS Tracks
		for (var t=0;t<tracks.length; t++) {
			// console.log(tracks[t]);
		}

		console.time('draw');

		var maxTracks = 0
		for (i=nodeTracks.length;i--;) {
			maxTracks = Math.max(maxTracks, nodeTracks[i]);
		}

		maxTracks = Math.min(10, maxTracks);

		console.log(maxTracks);

		var container = document.getElementById('container');
		var timeline_panel = document.getElementById('timeline_panel');
		var panel_spacer = document.getElementById('panel_spacer');
		var sliding_window = document.getElementById('sliding_window');

		container.style.left = (maxTracks + 2) * TRACK_WIDTH + 'px';

		panel_spacer.style.height = ROW_HEIGHT * timeline.length;

        var sa, rows;

        function initDimensions() {
            // calculations for viewport or new row count changes.
            sa = timeline_panel.scrollHeight - timeline_panel.clientHeight;
            rows = sa / timeline_panel.scrollHeight * timeline.length; // actual scrollable rows
        }

        initDimensions();

        window.addEventListener('resize', function() {
            console.log('resizing');
            initDimensions();
        })

		timeline_panel.addEventListener('scroll', function(e) {
			var p = timeline_panel.scrollTop / sa; // percentage scrolled
			var sliding = timeline_panel.scrollTop % ROW_HEIGHT;

			sliding_window.style.top = timeline_panel.scrollTop - sliding; //  - bufferRows * ROW_HEIGHT

			currentRow = p * rows | 0;

			// console.log(timeline.length, rows, currentRow, sa, sliding_window.style.top);

			draw();
		});

		/***** Setup DOMs ************/

		var canvas = document.createElement('canvas');
		canvas.id = 'graph';
		canvas.width = (maxTracks + 1) * TRACK_WIDTH;
		canvas.height = (targetRows + bufferRows * 2) * 25;
		sliding_window.insertBefore(canvas, container);

		var ctx = canvas.getContext('2d');
		ctx.lineWidth = 1.5;

		var divs = [], d;


		for (var j=0;j<(targetRows + bufferRows * 2);j++) {
			d = document.createElement('div');
			d.className = 'log';
			container.appendChild(d);
			divs.push(d);
		}

		var minRow, maxRow;
		var lastRenderered = 0;

		draw();
		console.timeEnd('draw');

		function getTrackX(t) {
			return ( maxTracks - t) * TRACK_WIDTH | 0.5 + 0.5;
		}

		function getRowY(t) {
			return t * ROW_HEIGHT + ROW_HEIGHT / 3; //+ offsetY
		}


		function draw() {

			var now = Date.now();
			if (now - lastRenderered < 16) {
				// console.log('skip');
				setTimeout(draw, 16);
				return;
			}

			minRow = Math.max(currentRow - bufferRows, 0);
			maxRow = Math.min(currentRow + targetRows + bufferRows, timeline.length);

			drawGraph();
			updateRows();

			lastRenderered = now;

			// setTimeout(function() {
			// 	timeline_panel.scrollTop += 50;
			// 	draw();
			// }, 20);

		}

		function drawGraph() {
			// Draw commit tracks
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			ctx.save();
			
			ctx.translate(0, getRowY(0)-getRowY(minRow));

			var track, entry;

			var i, il, j, jl;

			for (var i=0,il=tracks.length; i<il; i++) {
				track = tracks[i];

				ctx.strokeStyle = colors[i % colors.length];

				for (j=0, jl=track.length;j<jl;j++) {
					entry = track[j];
					if (entry.row >= minRow) break;
				}

				ctx.beginPath();
				
				ctx.moveTo(getTrackX(entry.lane), getRowY(entry.row));
				
				for (j=j+1, jl=track.length;j<jl;j++) {
					entry = track[j];

					ctx.lineTo(getTrackX(entry.lane), getRowY(entry.row));
					if (entry.row >= maxRow) break;
				}


                // ctx.lineTo(getTrackX(currentLane), getRowY(p.row + LINK_PORTION));
                // ctx.lineTo(getTrackX(endTrack), getRowY(i-LINK_PORTION));
                // ctx.lineTo(getTrackX(endTrack), getRowY(i));

                ctx.stroke();



                /*
                 Styles
                 - Solid Dot
                 - Empty Dot
                 - Outlined Dot
                 - Black White
                 */

                var colorScheme = 2;
                switch (colorScheme) {
                    case 0: // White outline, Black fill
                        ctx.fillStyle = Scheme.Black[Bright];
                        ctx.strokeStyle = Scheme.White[Bold];
                        break;
                    case 1: // Colored fill, empty outline
                        ctx.fillStyle = colors[i % colors.length];
                        ctx.strokeStyle = 'transparent';
                        break;
                    case 2: // Colored outline, empty fill
                        ctx.fillStyle = Scheme.Black[Bright];
                        ctx.strokeStyle = colors[i % colors.length];
                        break;
                    case 3: // Colored fill, empty outline
                        ctx.fillStyle = colors[i % colors.length];
                        ctx.strokeStyle = Scheme.White[Bold];
                        break;
                    case 4: // Black and white
                        ctx.fillStyle = Scheme.Black[Bold];
                        ctx.strokeStyle = Scheme.White[Bright];
                        break;
                }



                // Draw nodes
                for (j=0, jl=track.length;j<jl;j++) {
                    entry = track[j];
                    if (nodeTracks[entry.row] != entry.lane) continue;
                    ctx.beginPath();
                    ctx.arc(getTrackX(entry.lane), getRowY(entry.row), DOT_SIZE, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }

                // debug track points.
//				for (j=0, jl=track.length;j<jl;j++) {
//					entry = track[j];
//
//					ctx.beginPath();
//					ctx.arc(getTrackX(entry.lane), getRowY(entry.row), 2, 0, Math.PI * 2);
//					ctx.fill();
//
//					if (entry.row >= maxRow) break;
//				}
			}

			ctx.lineWidth = 1.5;

			// Draw nodes dots
//			for (i=minRow;i<maxRow;i++) {
//				nodeTrack = nodeTracks[i];
//
//				ctx.beginPath();
//				ctx.arc(getTrackX(nodeTrack), getRowY(i), DOT_SIZE, 0, Math.PI * 2);
//				ctx.fill();
//				ctx.stroke();
//			}

			ctx.restore();
		}

		function updateRows() {

			// Display commit messages
			for (i=minRow, j=0;i<maxRow;i++,j++) {
				commit = timeline[i];
				d = divs[j];
				d.innerHTML = '<span class="id">%id</span>. <span class="hash">%hash</span> <span class="message">%message</span>  <span class="author">%author</span> <span class="time">%time</span>'
					.replace(/%id/, replacer(timeline.length-i))
					.replace(/%message/, replacer(commit.message))
					.replace(/%time/, replacer(new Date(commit.date * 1000).toDateString()))
					.replace(/%hash/, replacer(commit.hash))
					.replace(/%author/, replacer(commit.author))
			}

		}

	}

	</script>
</body>
</html>