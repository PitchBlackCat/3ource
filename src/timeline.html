<html>
<body>
	<style>
	body {
		font-family: monospace;
	}
	#graph {
		position: absolute;
	}

	#container {
		position: absolute;
		left: 120px;
		white-space: nowrap; /*pre*/
	}

	.log {
		/*border: 1px solid blue;*/
		height: 25px;
	}
	</style>
	<div id="container"></div>
	<script>
	var request = new XMLHttpRequest();
	var url = '../data/test.json';
	var u;
	request.open( 'GET', url, true );
	request.onload = function(e) {
		console.time('decode');
		var timeline = JSON.parse(request.response);
		console.timeEnd('decode');
		readTimeline(timeline);
	}
	request.send(null);

	function readTimeline(timeline) {
		// console.log(timeline);
		window.t = timeline;
		// u = timeline.reverse();
		var i, il, v;
		var hashes = {};
		var targetRows = 200;

		function compare(a, b) {
			return b.date - a.date;
		}
		// Date order vs Ancestor order
		timeline.sort(compare);

		// create hashes
		for (i=0,il=timeline.length;i<il;i++) {
			v = timeline[i];
			v.children = [];
			hashes[v.hash] = v;
		}

		var parents, hash;

		// create reverse references
		for (i=0;i<il;i++) {
			v = timeline[i];
			parents = v.parents;
			for (j=0;j<parents.length;j++) {
				hash = parents[j];
				hashes[hash].children.push(v);
			}
		}

		var canvas = document.createElement('canvas');
		canvas.id = 'graph';
		canvas.width = 120;
		canvas.height = targetRows * 25;
		document.body.appendChild(canvas);

		// Graphing strategies
		// 1. pending parents first (gitk, jetbrains, git log --graph)
		// 2. Current node first, pending parents, remaining parents (sourcetree, gitx)
		// 3. Current parent, remaining parents, pending parents. (soucetree)
		// 4. force layout (github)

		// var
		ctx = canvas.getContext('2d');
		ctx.lineWidth = 2.5;
		// ctx.fillStyle = 'hsl(10%, 80%, 80%)';
		ctx.fillStyle = 'violet'; // lime

		var e;
		var pendingParents = [];
		var nodeTrack = 0;
		var p;
		var LINK_PORTION = 0.25;

		for (i=0;i<targetRows;i++) {
			v = timeline[i];
			e = document.createElement('div');
			e.className = 'log';
			e.innerHTML =  i + '. ' + v.message + " - " + new Date(v.date * 1000).toDateString() + ' - ' + v.hash + ' - ' + v.author;
			container.appendChild(e);

			var pendingParents2 = [];
			for (j=0;j<v.parents.length;j++) {
				pendingParents2.push({targetHash: v.parents[j],
					row: i, merge: true});
			}

			nodeTrack = null;
			var merges = 0;
			for (j=0;j<pendingParents.length;j++) {
				p = pendingParents[j];

				// Draw connecting lines
				ctx.beginPath();
				ctx.moveTo(getTrackX(p.track), getRowY(p.row+LINK_PORTION));

				p.row = i;
				if (p.targetHash==v.hash) {
					var first = nodeTrack===null;
					if (first) nodeTrack = j;

					ctx.lineTo(getTrackX(nodeTrack), getRowY(i));

					if (first && pendingParents2.length) {
						pendingParents[j] = pendingParents2.shift()
						pendingParents[j].track = j;
					} else {
						pendingParents.splice(j, 1);
						merges++;
						j--;
					}

				} else {
					p.track -= merges;
					ctx.lineTo(getTrackX(p.track), getRowY(i));
					p.merge = false;
				}

				ctx.stroke();

			}
			if (nodeTrack===null) {
				nodeTrack = 0;
			}

			//TODO fix this part!
			// console.log(nodeTrack);

			var uniqueTargets = {};
			var uniqueTargetsCount = 0, hash;

			// for (j=0;j<pendingParents.length;j++) {
			// 	hash = pendingParents[j].targetHash;
			// 	if (!(hash in uniqueTargets)) {
			// 		uniqueTargets[hash] = pendingParents[j].track;
			// 		uniqueTargetsCount++;
			// 	} else {
			// 		console.log('oh no!')
			// 	}
			// }

			uniqueTargetsCount = pendingParents.length;

			for (j=0;j<pendingParents2.length;j++) {
				p = pendingParents2[j];
				// if (p.targetHash in uniqueTargets) {
				// 	p.track = uniqueTargets[p.targetHash];
				// 	p.duplicate = true;
				// } else {
				// 	p.track = uniqueTargetsCount++;
				// }
				// p.track = pendingParents.length;

				// if (p.targetHash == timeline[i+1].hash) {
				// 	console.log('do something!', i)
				// }

				p.track = uniqueTargetsCount++;
				pendingParents.push(p);
			}



			// Draw 1/4 -> 1/3 portions of lines
			for (j=0;j<pendingParents.length;j++) {
				p = pendingParents[j];

				// Draw connecting lines
				ctx.beginPath();

				if (p.merge) {
					ctx.moveTo(getTrackX(nodeTrack), getRowY(i));
				} else {
					ctx.moveTo(getTrackX(p.track), getRowY(i));
				}

				ctx.lineTo(getTrackX(p.track), getRowY(i + LINK_PORTION));

				ctx.stroke();

			}

			// for (j=0;j<pendingParents.length;j++) {
			// 	if (pendingParents[j].duplicate) pendingParents.splice(j, 1);
			// }

			// Draw node

			ctx.beginPath();
			ctx.arc(getTrackX(nodeTrack), getRowY(i), 6, 0, Math.PI * 2);
			ctx.fill();
		}

		function getTrackX(t) {
			return t * 16 + 6;
		}

		function getRowY(t) {
			return t * 25 + 10;
		}



	}

	</script>
</body>
</html>