<html>
<body>
	<style>
	body {
		font-family: monospace;
	}

	</style>
	<script src="lib/three.min.js"></script>
	<script src="source.js"></script>
	<script src="nodes.js"></script>
	<div id="container">Test Filesystem.</div>
	type root.ls(); in console.
	<script>

	var plane = new THREE.PlaneGeometry( 20, 20 );
	var lineMaterial = new THREE.LineBasicMaterial( { color: 0x444fff, opacity: 1, linewidth: 3, vertexColors: THREE.VertexColors } );
	var materials = [];
	for (i=0;i<50;i++) {
		materials.push(new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } ));
	}


	var scene = new THREE.Scene();
	var root = new TreeNode('/');

	var tmp = new THREE.Vector3();

	var url = '../data/test.json';
	requestLog(url, readTimeline);

	var target = new THREE.Vector3( 0, 0, 0 );

	function compare(a, b) {
		return a.time - b.time;
	}

	var amd_priority = {A: 0, M: 1, D: 2}
	function amdSort(a, b) {
		a = amd_priority[a.op]
		b = amd_priority[b.op];

	    if(a>b) return -1;
	    if(a<b) return 1;
	    return 0;
	}

	function debugo(array, key) {
		var moo = [];
		for (var i=0;i<array.length;i++) {
			moo.push(array[i][key]);
		}
		return moo.join(',');
	}

	function readTimeline(timeline) {
		// TEST STUFF HERE
		// timeline = timeline.sort(compare);
		console.time('done');
		timeline = timeline.reverse();

		console.log(timeline);
		window.t = timeline;
		var i,il, commit, j, entry, filename;

		var commits_hash = {};
		window.c = commits_hash;
		// file
		var tree;

		var added = 0, modified = 0, deleted = 0;
		var adding = false;
		var removing = false;


		for (i=0, il=timeline.length;i<il;i++) {
			commit = timeline[i];
			commits_hash[commit.hash] = commit;
		}


		for (i=0;i<timeline.length;i++) { //timeline.length
		// for (i=timeline.length;i--;) { //timeline.length
			commit = timeline[i];
			files = commit.files;

			tree = commit.tree = [];
			parents = commit.parents;

			var dups = {};

			if (parents.length==2) {
				a = commits_hash[parents[0]].tree
				b = commits_hash[parents[1]].tree
			}

			for (j = 0, jl=parents.length; j<jl; j++) {
				parent_hash = parents[j];
				merge = commits_hash[parent_hash].tree;

				if (!(parent_hash in commits_hash)) console.log('parent hash not found');
				if (!merge) console.log('unable to retrieve parents tree');

				for (k=0,kl=merge.length;k<kl;k++) {
					merging = merge[k];
					key = merging.to; //merging.to
					if (!(key in dups)) {
						dups[key] = {count: 0, object: merging};
						// slog(0.0001, merging);
					} else {
						// (dups[key].object.to != merging.to) &&
						// console.log('opps');
					}
					dups[key].count++;

					// tree.push(merging);

				}

			}

			for (j in dups) {
				// if (dups[j].count == jl)
					tree.push(dups[j].object);
			}

			files.sort(amdSort);
			// files.reverse();


			// console.log(commit);

			// for (j=0, jl=files.length;j<jl;j++) {
			for (j=files.length;j--;) {
				file = files[j];

				prev_hash = file.from;
				current_hash = file.to;
				filename = file.file;
				// file.commit = commit.hash;

				switch (file.op) {
					case 'A':
						adding = true;
						removing = false;
						break;
					case 'M':
						adding = true;
						removing = true;
						// adding = removing = false;
						break;
					case 'D':
						adding = false;
						removing = true;
						break;
				}

				// tree[current_hash] = filename;
				if (removing) {
					var found = 0;
					for (k=tree.length;k--;) {
						if (tree[k].to == prev_hash  ) { //  || tree[k].file == filename
							tree.splice(k, 1);
							found++;
							// break;
						}
					}
				}

				if (adding) {
					tree.push(file);
				}



				// console.log('.');

			}

			slog(0.01, i, tree.length);
			// console.log(tree.length, parents.length);
			// i % 1 == 0 && console.log(i);
			// Math.random() < 0.01 && console.log(i);

			// if (parents.length>1) return;

		}

		treelog(t[t.length-1].tree)
		console.timeEnd('done');

	}

	function slog() {
		var args = Array.prototype.slice.call(arguments);
		var sample = args.shift();
		(Math.random() < sample) && console.log.apply(console, args);
	}



	function treelog(tree) {
		var uniq = {}, u =0;
		tree = tree.sort(function(a,b){
    if(a.file<b.file) return -1;
    if(a.file>b.file) return 1;
    return 0;
});
		for (var i=0, il=tree.length; i<il;i++) {
			filename = tree[i].file
			console.log(filename);
			if (!(filename in uniq)) {
				uniq[filename] = null;
				u++;
			}
		}

		console.log('Files: ' + il, u)
	}


	</script>
</body>
</html>